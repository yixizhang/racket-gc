week 04-08-13

#= ToDo =#
simulate memory hiearchy and similate mem-looking time
free-list (probably 2 different tags to save find-free-space time)
change the heap size metrics to graph with time
test diffent graph of memeory allocation patterns
rebase with master head of plt/racket
write xml->html or html->x-exprs sample code
update mutator-cond macro to support (begin e ...) for each branch
maybe double vector size when all slots are filled (check paper/algo/wiki)
use html lib to parse this page, http://docs.racket-lang.org/guide/performance.html#%28part._.Reachability_and_.Garbage_.Collection%29

#= Finished =#
add benchmarks to generational collector
add benchmarks to hybrid collector
make heap-value? case in scheme->gc roots
combine generational gc and incremental gc
incrementalize mark-white! and free-white
make generational gc support vector and struct
fix incremental gc's heap-check
add modulo, etc., to mutator
try depth-first for copying traverse/ref
add void to mutator
support of vector/struct/struct-instance for gc->scheme/member?/equal?, etc.
update mutator so it supports *values*
add make-vector/vector-ref/vector-set!, etc., in mutator
stored in vector slot should be ptr to pair
each hash-key corresponds to a list of values
gc:vector should alloc a vector and set each slot to given loc
(and (procedure? fail) (procedure-arity-includes? fail 0))
make-pointers-to-2nd-gen-root should check the case that to-space in young generation is exactly full
change if to cond in gc:vector-set!
